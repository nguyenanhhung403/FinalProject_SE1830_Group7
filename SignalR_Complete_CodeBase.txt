================================================================================
                    SIGNALR COMPLETE CODEBASE
                    EV Warranty Management System
================================================================================

This file contains all SignalR-related code from the project, organized by category.
Each section includes the file path and complete source code.

================================================================================
                        TABLE OF CONTENTS
================================================================================

I.   BACKEND C# CODE
     1. NotificationHub.cs
     2. ChatHub.cs
     3. INotificationService.cs
     4. NotificationService.cs
     5. MessageService.cs
     6. Program.cs (SignalR Configuration)
     7. Claims Page Models (SignalR Usage)

II.  FRONTEND JAVASCRIPT
     1. signalr-connection.js
     2. dashboard-realtime.js
     3. claims-realtime.js
     4. chat.js

III. STYLING
     1. signalr-styles.css

IV.  DATABASE
     1. AddClaimMessagesTable.sql

================================================================================
                    I. BACKEND C# CODE
================================================================================

--------------------------------------------------------------------------------
File: EVWarrantyManagement/Hubs/NotificationHub.cs
--------------------------------------------------------------------------------

using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.SignalR;
using System.Collections.Concurrent;

namespace EVWarrantyManagement.UI.Hubs
{
    /// <summary>
    /// SignalR Hub for handling real-time notifications across the application
    /// Manages user connections, role-based groups, and notification broadcasting
    /// </summary>
    [Authorize]
    public class NotificationHub : Hub
    {
        // Thread-safe dictionary to track user connections
        private static readonly ConcurrentDictionary<string, UserConnectionInfo> _userConnections = new();

        /// <summary>
        /// Called when a new connection is established
        /// Adds user to role-based groups for targeted notifications
        /// </summary>
        public override async Task OnConnectedAsync()
        {
            var userId = Context.UserIdentifier; // Gets UserId from authenticated user
            var connectionId = Context.ConnectionId;

            // Get user's role from claims
            var userRole = Context.User?.Claims
                .FirstOrDefault(c => c.Type == System.Security.Claims.ClaimTypes.Role)?.Value;

            if (!string.IsNullOrEmpty(userId) && !string.IsNullOrEmpty(userRole))
            {
                // Store connection info
                _userConnections[connectionId] = new UserConnectionInfo
                {
                    UserId = userId,
                    ConnectionId = connectionId,
                    Role = userRole
                };

                // Add to role-based group
                await Groups.AddToGroupAsync(connectionId, userRole);

                // Notify others that user is online (optional)
                await Clients.Others.SendAsync("UserConnected", userId, userRole);
            }

            await base.OnConnectedAsync();
        }

        /// <summary>
        /// Called when a connection is terminated
        /// Cleans up user connection tracking
        /// </summary>
        public override async Task OnDisconnectedAsync(Exception? exception)
        {
            var connectionId = Context.ConnectionId;

            if (_userConnections.TryRemove(connectionId, out var userInfo))
            {
                // Notify others that user is offline (optional)
                await Clients.Others.SendAsync("UserDisconnected", userInfo.UserId);
            }

            await base.OnDisconnectedAsync(exception);
        }

        /// <summary>
        /// Join a claim-specific group to receive updates about a particular claim
        /// Used when user opens a claim details page
        /// </summary>
        /// <param name="claimId">The claim ID to join</param>
        public async Task JoinClaimGroup(int claimId)
        {
            await Groups.AddToGroupAsync(Context.ConnectionId, $"Claim_{claimId}");
        }

        /// <summary>
        /// Leave a claim-specific group
        /// Used when user leaves a claim details page
        /// </summary>
        /// <param name="claimId">The claim ID to leave</param>
        public async Task LeaveClaimGroup(int claimId)
        {
            await Groups.RemoveFromGroupAsync(Context.ConnectionId, $"Claim_{claimId}");
        }

        /// <summary>
        /// Get all online users (Admin only)
        /// </summary>
        [Authorize(Policy = "AdminOnly")]
        public List<UserConnectionInfo> GetOnlineUsers()
        {
            return _userConnections.Values.ToList();
        }

        /// <summary>
        /// Send notification to specific user
        /// </summary>
        public async Task SendToUser(string userId, string message, string type = "info")
        {
            await Clients.User(userId).SendAsync("ReceiveNotification", message, type);
        }

        /// <summary>
        /// Send notification to all users in a role
        /// </summary>
        public async Task SendToRole(string role, string message, string type = "info")
        {
            await Clients.Group(role).SendAsync("ReceiveNotification", message, type);
        }

        /// <summary>
        /// Send claim update notification to all users watching a claim
        /// </summary>
        public async Task SendClaimUpdate(int claimId, object claimData)
        {
            await Clients.Group($"Claim_{claimId}").SendAsync("ReceiveClaimUpdate", claimData);
        }

        /// <summary>
        /// Broadcast notification to all connected users
        /// </summary>
        [Authorize(Policy = "AdminOnly")]
        public async Task BroadcastNotification(string message, string type = "info")
        {
            await Clients.All.SendAsync("ReceiveNotification", message, type);
        }
    }

    /// <summary>
    /// Information about a connected user
    /// </summary>
    public class UserConnectionInfo
    {
        public string UserId { get; set; } = string.Empty;
        public string ConnectionId { get; set; } = string.Empty;
        public string Role { get; set; } = string.Empty;
        public DateTime ConnectedAt { get; set; } = DateTime.UtcNow;
    }
}

--------------------------------------------------------------------------------
File: EVWarrantyManagement/Hubs/ChatHub.cs
--------------------------------------------------------------------------------

using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.SignalR;
using System.Collections.Concurrent;

namespace EVWarrantyManagement.UI.Hubs
{
    /// <summary>
    /// SignalR Hub for handling real-time chat/messaging functionality
    /// Enables communication between users regarding specific warranty claims
    /// </summary>
    [Authorize]
    public class ChatHub : Hub
    {
        // Track users currently typing in specific claims
        private static readonly ConcurrentDictionary<string, HashSet<string>> _typingUsers = new();

        /// <summary>
        /// Called when a new connection is established
        /// </summary>
        public override async Task OnConnectedAsync()
        {
            var userId = Context.UserIdentifier;
            var username = Context.User?.Claims
                .FirstOrDefault(c => c.Type == System.Security.Claims.ClaimTypes.Name)?.Value;

            await base.OnConnectedAsync();
        }

        /// <summary>
        /// Called when a connection is terminated
        /// Cleans up typing indicators
        /// </summary>
        public override async Task OnDisconnectedAsync(Exception? exception)
        {
            var userId = Context.UserIdentifier;

            // Remove from all typing indicators
            foreach (var key in _typingUsers.Keys)
            {
                if (_typingUsers.TryGetValue(key, out var users))
                {
                    users.Remove(userId ?? "");
                }
            }

            await base.OnDisconnectedAsync(exception);
        }

        /// <summary>
        /// Join a claim chat room
        /// </summary>
        /// <param name="claimId">The claim ID to join</param>
        public async Task JoinClaimChat(int claimId)
        {
            var username = Context.User?.Claims
                .FirstOrDefault(c => c.Type == System.Security.Claims.ClaimTypes.Name)?.Value;

            await Groups.AddToGroupAsync(Context.ConnectionId, $"ClaimChat_{claimId}");

            // Notify others in the room
            await Clients.OthersInGroup($"ClaimChat_{claimId}")
                .SendAsync("UserJoined", username, DateTime.UtcNow);
        }

        /// <summary>
        /// Leave a claim chat room
        /// </summary>
        /// <param name="claimId">The claim ID to leave</param>
        public async Task LeaveClaimChat(int claimId)
        {
            var username = Context.User?.Claims
                .FirstOrDefault(c => c.Type == System.Security.Claims.ClaimTypes.Name)?.Value;

            await Groups.RemoveFromGroupAsync(Context.ConnectionId, $"ClaimChat_{claimId}");

            // Notify others in the room
            await Clients.OthersInGroup($"ClaimChat_{claimId}")
                .SendAsync("UserLeft", username, DateTime.UtcNow);

            // Remove from typing users
            var key = $"ClaimChat_{claimId}";
            if (_typingUsers.TryGetValue(key, out var users))
            {
                users.Remove(Context.UserIdentifier ?? "");
            }
        }

        /// <summary>
        /// Send a message to a claim chat room
        /// This is called from client, then service will persist to DB and broadcast
        /// </summary>
        /// <param name="claimId">The claim ID</param>
        /// <param name="message">The message content</param>
        public async Task SendMessage(int claimId, string message)
        {
            var userId = Context.UserIdentifier;
            var username = Context.User?.Claims
                .FirstOrDefault(c => c.Type == System.Security.Claims.ClaimTypes.Name)?.Value;

            var messageData = new
            {
                ClaimId = claimId,
                UserId = userId,
                Username = username,
                Message = message,
                Timestamp = DateTime.UtcNow
            };

            // Broadcast to all users in the claim chat room
            await Clients.Group($"ClaimChat_{claimId}")
                .SendAsync("ReceiveMessage", messageData);

            // Stop typing indicator for this user
            await UserStoppedTyping(claimId);
        }

        /// <summary>
        /// Notify others that user is typing
        /// </summary>
        /// <param name="claimId">The claim ID</param>
        public async Task UserTyping(int claimId)
        {
            var userId = Context.UserIdentifier;
            var username = Context.User?.Claims
                .FirstOrDefault(c => c.Type == System.Security.Claims.ClaimTypes.Name)?.Value;

            if (string.IsNullOrEmpty(userId)) return;

            var key = $"ClaimChat_{claimId}";
            var users = _typingUsers.GetOrAdd(key, _ => new HashSet<string>());

            lock (users)
            {
                users.Add(userId);
            }

            // Notify others in the room
            await Clients.OthersInGroup($"ClaimChat_{claimId}")
                .SendAsync("UserIsTyping", username);
        }

        /// <summary>
        /// Notify others that user stopped typing
        /// </summary>
        /// <param name="claimId">The claim ID</param>
        public async Task UserStoppedTyping(int claimId)
        {
            var userId = Context.UserIdentifier;
            var username = Context.User?.Claims
                .FirstOrDefault(c => c.Type == System.Security.Claims.ClaimTypes.Name)?.Value;

            if (string.IsNullOrEmpty(userId)) return;

            var key = $"ClaimChat_{claimId}";
            if (_typingUsers.TryGetValue(key, out var users))
            {
                lock (users)
                {
                    users.Remove(userId);
                }
            }

            // Notify others in the room
            await Clients.OthersInGroup($"ClaimChat_{claimId}")
                .SendAsync("UserStoppedTyping", username);
        }

        /// <summary>
        /// Mark messages as read by the current user
        /// </summary>
        /// <param name="claimId">The claim ID</param>
        public async Task MarkMessagesAsRead(int claimId)
        {
            var userId = Context.UserIdentifier;

            // This would typically call a service method to update the database
            // For now, we'll just notify the group
            await Clients.Group($"ClaimChat_{claimId}")
                .SendAsync("MessagesRead", userId, DateTime.UtcNow);
        }

        /// <summary>
        /// Get the list of users currently in a claim chat
        /// </summary>
        /// <param name="claimId">The claim ID</param>
        public async Task GetActiveUsers(int claimId)
        {
            // This would query the connection tracking
            // For now, just acknowledge the request
            await Task.CompletedTask;
        }
    }
}

--------------------------------------------------------------------------------
File: EVWarrantyManagement.BLL/Interfaces/INotificationService.cs
--------------------------------------------------------------------------------

namespace EVWarrantyManagement.BLL.Interfaces
{
    /// <summary>
    /// Service for sending real-time notifications via SignalR
    /// Handles claim status updates, user activities, and system notifications
    /// </summary>
    public interface INotificationService
    {
        /// <summary>
        /// Notify users when a claim status changes
        /// </summary>
        Task NotifyClaimStatusChangedAsync(int claimId, string newStatus, string? oldStatus = null, string? note = null);

        /// <summary>
        /// Notify EVM staff when a new claim is created
        /// </summary>
        Task NotifyNewClaimCreatedAsync(int claimId, string vin, string serviceCenterName);

        /// <summary>
        /// Notify relevant users when a part is added to a claim
        /// </summary>
        Task NotifyPartAddedAsync(int claimId, string partName, decimal cost, int? technicianId = null);

        /// <summary>
        /// Notify technician when a claim is assigned to them
        /// </summary>
        Task NotifyClaimAssignedAsync(int claimId, int technicianId, string technicianName);

        /// <summary>
        /// Notify users in a claim group about an update
        /// </summary>
        Task NotifyClaimUpdateAsync(int claimId, string message, string type = "info");

        /// <summary>
        /// Send notification to specific user
        /// </summary>
        Task SendToUserAsync(string userId, string message, string type = "info");

        /// <summary>
        /// Send notification to all users with a specific role
        /// </summary>
        Task SendToRoleAsync(string role, string message, string type = "info");

        /// <summary>
        /// Broadcast notification to all connected users (Admin only)
        /// </summary>
        Task BroadcastNotificationAsync(string message, string type = "info");
    }
}

--------------------------------------------------------------------------------
File: EVWarrantyManagement.BLL/Services/NotificationService.cs
--------------------------------------------------------------------------------

using EVWarrantyManagement.BLL.Interfaces;

namespace EVWarrantyManagement.BLL.Services
{
    /// <summary>
    /// Service for sending real-time notifications via SignalR
    /// Note: This is a stub service. Actual SignalR notifications should be
    /// triggered from the UI layer using IHubContext directly to avoid circular dependencies.
    /// The UI layer should inject IHubContext and call hub methods directly.
    /// </summary>
    public class NotificationService : INotificationService
    {
        public NotificationService()
        {
        }

        /// <summary>
        /// Notify users when a claim status changes
        /// Note: Implement in UI layer with IHubContext injection
        /// </summary>
        public Task NotifyClaimStatusChangedAsync(int claimId, string newStatus, string? oldStatus = null, string? note = null)
        {
            // Implemented at UI layer
            return Task.CompletedTask;
        }

        /// <summary>
        /// Notify EVM staff when a new claim is created
        /// Note: Implement in UI layer with IHubContext injection
        /// </summary>
        public Task NotifyNewClaimCreatedAsync(int claimId, string vin, string serviceCenterName)
        {
            // Implemented at UI layer
            return Task.CompletedTask;
        }

        /// <summary>
        /// Notify relevant users when a part is added to a claim
        /// Note: Implement in UI layer with IHubContext injection
        /// </summary>
        public Task NotifyPartAddedAsync(int claimId, string partName, decimal cost, int? technicianId = null)
        {
            // Implemented at UI layer
            return Task.CompletedTask;
        }

        /// <summary>
        /// Notify technician when a claim is assigned to them
        /// Note: Implement in UI layer with IHubContext injection
        /// </summary>
        public Task NotifyClaimAssignedAsync(int claimId, int technicianId, string technicianName)
        {
            // Implemented at UI layer
            return Task.CompletedTask;
        }

        /// <summary>
        /// Notify users in a claim group about an update
        /// Note: Implement in UI layer with IHubContext injection
        /// </summary>
        public Task NotifyClaimUpdateAsync(int claimId, string message, string type = "info")
        {
            // Implemented at UI layer
            return Task.CompletedTask;
        }

        /// <summary>
        /// Send notification to specific user
        /// Note: Implement in UI layer with IHubContext injection
        /// </summary>
        public Task SendToUserAsync(string userId, string message, string type = "info")
        {
            // Implemented at UI layer
            return Task.CompletedTask;
        }

        /// <summary>
        /// Send notification to all users with a specific role
        /// Note: Implement in UI layer with IHubContext injection
        /// </summary>
        public Task SendToRoleAsync(string role, string message, string type = "info")
        {
            // Implemented at UI layer
            return Task.CompletedTask;
        }

        /// <summary>
        /// Broadcast notification to all connected users
        /// Note: Implement in UI layer with IHubContext injection
        /// </summary>
        public Task BroadcastNotificationAsync(string message, string type = "info")
        {
            // Implemented at UI layer
            return Task.CompletedTask;
        }
    }
}

--------------------------------------------------------------------------------
File: EVWarrantyManagement.BLL/Services/MessageService.cs
--------------------------------------------------------------------------------

using EVWarrantyManagement.BLL.Interfaces;
using EVWarrantyManagement.BO.Models;
using EVWarrantyManagement.DAL.Interfaces;

namespace EVWarrantyManagement.BLL.Services
{
    /// <summary>
    /// Service for managing claim messages
    /// Note: SignalR broadcasting should be done in the UI layer with IHubContext
    /// </summary>
    public class MessageService : IMessageService
    {
        private readonly IMessageRepository _messageRepository;

        public MessageService(IMessageRepository messageRepository)
        {
            _messageRepository = messageRepository;
        }

        /// <summary>
        /// Get all messages for a specific claim
        /// </summary>
        public async Task<List<ClaimMessage>> GetMessagesByClaimIdAsync(int claimId)
        {
            return await _messageRepository.GetMessagesByClaimIdAsync(claimId);
        }

        /// <summary>
        /// Send a new message (without SignalR broadcasting - handle that in UI layer)
        /// </summary>
        public async Task<ClaimMessage> SendMessageAsync(int claimId, int userId, string message)
        {
            var claimMessage = new ClaimMessage
            {
                ClaimId = claimId,
                UserId = userId,
                Message = message,
                Timestamp = DateTime.UtcNow,
                IsRead = false
            };

            var savedMessage = await _messageRepository.CreateMessageAsync(claimMessage);

            // Note: SignalR broadcasting should be done in UI layer after calling this method

            return savedMessage;
        }

        /// <summary>
        /// Mark a message as read
        /// </summary>
        public async Task MarkMessageAsReadAsync(int messageId)
        {
            await _messageRepository.MarkMessageAsReadAsync(messageId);
        }

        /// <summary>
        /// Mark all messages in a claim as read for the current user
        /// </summary>
        public async Task MarkClaimMessagesAsReadAsync(int claimId, int userId)
        {
            await _messageRepository.MarkClaimMessagesAsReadAsync(claimId, userId);

            // Note: SignalR notifications should be handled in UI layer
        }

        /// <summary>
        /// Get unread message count for a user
        /// </summary>
        public async Task<int> GetUnreadMessageCountAsync(int userId)
        {
            return await _messageRepository.GetUnreadMessageCountAsync(userId);
        }

        /// <summary>
        /// Get unread message count for a specific claim
        /// </summary>
        public async Task<int> GetUnreadMessageCountByClaimAsync(int claimId, int userId)
        {
            return await _messageRepository.GetUnreadMessageCountByClaimAsync(claimId, userId);
        }

        /// <summary>
        /// Delete a message (with authorization check in the calling layer)
        /// </summary>
        public async Task DeleteMessageAsync(int messageId, int userId)
        {
            var message = await _messageRepository.GetMessageByIdAsync(messageId);

            if (message != null && message.UserId == userId)
            {
                await _messageRepository.DeleteMessageAsync(messageId);

                // Note: SignalR notifications should be handled in UI layer
            }
        }

        /// <summary>
        /// Get recent messages for a claim
        /// </summary>
        public async Task<List<ClaimMessage>> GetRecentMessagesAsync(int claimId, int count = 50)
        {
            return await _messageRepository.GetRecentMessagesAsync(claimId, count);
        }
    }
}

--------------------------------------------------------------------------------
File: EVWarrantyManagement/Program.cs (SignalR Configuration)
--------------------------------------------------------------------------------

// RELEVANT SECTIONS FROM Program.cs

// Line 13-14: Add SignalR service
builder.Services.AddSignalR();

// Line 36-37: Register SignalR-related services
builder.Services.AddScoped<INotificationService, NotificationService>();
builder.Services.AddScoped<IMessageService, MessageService>();

// Line 111-112: Map SignalR hub endpoints
app.MapHub<EVWarrantyManagement.UI.Hubs.NotificationHub>("/hubs/notification");
app.MapHub<EVWarrantyManagement.UI.Hubs.ChatHub>("/hubs/chat");

--------------------------------------------------------------------------------
File: EVWarrantyManagement/Pages/Claims/Details.cshtml.cs (SignalR Usage Example)
--------------------------------------------------------------------------------

// RELEVANT SECTIONS showing IHubContext usage

using Microsoft.AspNetCore.SignalR;
using EVWarrantyManagement.UI.Hubs;

public class DetailsModel : PageModel
{
    private readonly IHubContext<NotificationHub> _notificationHub;

    public DetailsModel(
        IWarrantyClaimService claimService,
        IPartService partService,
        IHubContext<NotificationHub> notificationHub)
    {
        _claimService = claimService;
        _partService = partService;
        _notificationHub = notificationHub;
    }

    // Example: Sending notification when part is added
    // await _notificationHub.Clients.Group("EVM Staff")
    //     .SendAsync("ReceiveClaimUpdate", notificationData);
}

--------------------------------------------------------------------------------
File: EVWarrantyManagement/Pages/Claims/Create.cshtml.cs (SignalR Usage Example)
--------------------------------------------------------------------------------

// RELEVANT SECTIONS showing IHubContext usage

using Microsoft.AspNetCore.SignalR;
using EVWarrantyManagement.UI.Hubs;

public class CreateModel : PageModel
{
    private readonly IHubContext<NotificationHub> _notificationHub;

    public CreateModel(
        IWarrantyClaimService claimService,
        IWebHostEnvironment env,
        IVehicleService vehicleService,
        EVWarrantyManagement.DAL.EVWarrantyManagementContext db,
        IHubContext<NotificationHub> notificationHub)
    {
        _claimService = claimService;
        _env = env;
        _vehicleService = vehicleService;
        _db = db;
        _notificationHub = notificationHub;
    }

    // Example: Notifying EVM Staff when new claim is created
    // await _notificationHub.Clients.Group("EVM Staff")
    //     .SendAsync("ReceiveNewClaim", claimData);
}

================================================================================
                    II. FRONTEND JAVASCRIPT
================================================================================

--------------------------------------------------------------------------------
File: EVWarrantyManagement/wwwroot/js/signalr-connection.js
--------------------------------------------------------------------------------

/**
 * SignalR Connection Manager
 * Handles connection, reconnection, and event handling for SignalR hubs
 */

class SignalRConnection {
    constructor(hubUrl) {
        this.hubUrl = hubUrl;
        this.connection = null;
        this.isConnected = false;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 10;
        this.reconnectDelay = 3000; // Start with 3 seconds
        this.eventHandlers = new Map();
    }

    /**
     * Initialize and start the connection
     */
    async start() {
        try {
            // Build the connection
            this.connection = new signalR.HubConnectionBuilder()
                .withUrl(this.hubUrl)
                .withAutomaticReconnect({
                    nextRetryDelayInMilliseconds: retryContext => {
                        // Exponential backoff: 0, 2, 10, 30 seconds, then 30 seconds
                        if (retryContext.elapsedMilliseconds < 60000) {
                            return Math.min(1000 * Math.pow(2, retryContext.previousRetryCount), 30000);
                        } else {
                            // After 1 minute, give up
                            return null;
                        }
                    }
                })
                .configureLogging(signalR.LogLevel.Information)
                .build();

            // Set up event handlers
            this.connection.onreconnecting(error => {
                console.warn(`Connection lost. Reconnecting... ${error}`);
                this.isConnected = false;
                this.onConnectionStateChanged('reconnecting');
            });

            this.connection.onreconnected(connectionId => {
                console.log(`Reconnected. Connection ID: ${connectionId}`);
                this.isConnected = true;
                this.reconnectAttempts = 0;
                this.onConnectionStateChanged('connected');
            });

            this.connection.onclose(error => {
                console.error(`Connection closed. ${error}`);
                this.isConnected = false;
                this.onConnectionStateChanged('disconnected');

                // Attempt manual reconnect after delay
                if (this.reconnectAttempts < this.maxReconnectAttempts) {
                    setTimeout(() => this.manualReconnect(), this.reconnectDelay);
                }
            });

            // Register all event handlers
            this.eventHandlers.forEach((handler, eventName) => {
                this.connection.on(eventName, handler);
            });

            // Start the connection
            await this.connection.start();
            this.isConnected = true;
            this.reconnectAttempts = 0;
            console.log(`SignalR connected to ${this.hubUrl}`);
            this.onConnectionStateChanged('connected');

            return this.connection;
        } catch (error) {
            console.error('Error starting SignalR connection:', error);
            this.onConnectionStateChanged('error');

            // Attempt to reconnect
            if (this.reconnectAttempts < this.maxReconnectAttempts) {
                setTimeout(() => this.manualReconnect(), this.reconnectDelay);
            }

            throw error;
        }
    }

    /**
     * Manual reconnection with exponential backoff
     */
    async manualReconnect() {
        this.reconnectAttempts++;
        this.reconnectDelay = Math.min(this.reconnectDelay * 2, 30000); // Max 30 seconds

        console.log(`Reconnect attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts}`);

        try {
            await this.start();
        } catch (error) {
            console.error(`Reconnect attempt ${this.reconnectAttempts} failed:`, error);
        }
    }

    /**
     * Register an event handler
     */
    on(eventName, handler) {
        this.eventHandlers.set(eventName, handler);
        if (this.connection) {
            this.connection.on(eventName, handler);
        }
    }

    /**
     * Unregister an event handler
     */
    off(eventName) {
        this.eventHandlers.delete(eventName);
        if (this.connection) {
            this.connection.off(eventName);
        }
    }

    /**
     * Invoke a hub method
     */
    async invoke(methodName, ...args) {
        if (!this.isConnected || !this.connection) {
            console.warn('Cannot invoke method: Not connected');
            return null;
        }

        try {
            return await this.connection.invoke(methodName, ...args);
        } catch (error) {
            console.error(`Error invoking ${methodName}:`, error);
            throw error;
        }
    }

    /**
     * Send a message without waiting for response
     */
    async send(methodName, ...args) {
        if (!this.isConnected || !this.connection) {
            console.warn('Cannot send message: Not connected');
            return;
        }

        try {
            await this.connection.send(methodName, ...args);
        } catch (error) {
            console.error(`Error sending ${methodName}:`, error);
        }
    }

    /**
     * Stop the connection
     */
    async stop() {
        if (this.connection) {
            await this.connection.stop();
            this.isConnected = false;
            this.onConnectionStateChanged('disconnected');
        }
    }

    /**
     * Override this method to handle connection state changes
     */
    onConnectionStateChanged(state) {
        // To be overridden by subclasses or instances
        console.log(`Connection state changed: ${state}`);
    }

    /**
     * Get current connection state
     */
    getState() {
        if (!this.connection) return 'disconnected';

        switch (this.connection.state) {
            case signalR.HubConnectionState.Connected:
                return 'connected';
            case signalR.HubConnectionState.Connecting:
                return 'connecting';
            case signalR.HubConnectionState.Reconnecting:
                return 'reconnecting';
            case signalR.HubConnectionState.Disconnected:
                return 'disconnected';
            default:
                return 'unknown';
        }
    }
}

// Export for use in other scripts
window.SignalRConnection = SignalRConnection;

--------------------------------------------------------------------------------
File: EVWarrantyManagement/wwwroot/js/dashboard-realtime.js
--------------------------------------------------------------------------------

/**
 * Dashboard Real-Time Updates via SignalR
 * Handles live notifications and dashboard data updates
 */

class DashboardRealTime {
    constructor() {
        this.notificationHub = null;
        this.isInitialized = false;
    }

    /**
     * Initialize the dashboard real-time connection
     */
    async initialize() {
        if (this.isInitialized) {
            console.warn('Dashboard real-time already initialized');
            return;
        }

        try {
            // Create SignalR connection to notification hub
            this.notificationHub = new SignalRConnection('/hubs/notification');

            // Register event handlers
            this.registerEventHandlers();

            // Start the connection
            await this.notificationHub.start();

            this.isInitialized = true;
            console.log('Dashboard real-time initialized');

            // Update connection status indicator
            this.updateConnectionStatus('connected');

        } catch (error) {
            console.error('Failed to initialize dashboard real-time:', error);
            this.updateConnectionStatus('error');
        }
    }

    /**
     * Register SignalR event handlers
     */
    registerEventHandlers() {
        // Handle general notifications
        this.notificationHub.on('ReceiveNotification', (message, type) => {
            this.handleNotification(message, type);
        });

        // Handle new claim notifications
        this.notificationHub.on('ReceiveNewClaim', (data) => {
            this.handleNewClaim(data);
        });

        // Handle claim update notifications
        this.notificationHub.on('ReceiveClaimUpdate', (data) => {
            this.handleClaimUpdate(data);
        });

        // Handle user connection events
        this.notificationHub.on('UserConnected', (userId, role) => {
            console.log(`User ${userId} (${role}) connected`);
        });

        this.notificationHub.on('UserDisconnected', (userId) => {
            console.log(`User ${userId} disconnected`);
        });

        // Override connection state change handler
        this.notificationHub.onConnectionStateChanged = (state) => {
            this.updateConnectionStatus(state);
        };
    }

    /**
     * Handle general notification
     */
    handleNotification(message, type = 'info') {
        // Show toast notification
        if (window.notificationToast) {
            window.notificationToast.show(message, type);
        }

        // Log to console
        console.log(`[${type.toUpperCase()}] ${message}`);
    }

    /**
     * Handle new claim notification
     */
    handleNewClaim(data) {
        console.log('New claim received:', data);

        // Show notification
        this.handleNotification(data.Message, 'info');

        // Increment notification bell counter
        if (window.notificationManager) {
            window.notificationManager.increment();
        }

        // Increment pending claims counter
        const pendingCounter = document.getElementById('pending-claims-count');
        if (pendingCounter) {
            const currentCount = parseInt(pendingCounter.textContent) || 0;
            pendingCounter.textContent = currentCount + 1;

            // Add animation
            pendingCounter.classList.add('badge-pulse');
            setTimeout(() => pendingCounter.classList.remove('badge-pulse'), 1000);
        }

        // Add claim to dashboard table
        this.addClaimToDashboardTable(data);

        // If we're on the dashboard, reload the claims chart/table
        if (typeof refreshDashboardData === 'function') {
            refreshDashboardData();
        }

        // Add to recent claims list if exists
        this.addClaimToRecentList(data);
    }

    /**
     * Handle claim update notification
     */
    handleClaimUpdate(data) {
        console.log('Claim update received:', data);

        // Update claim in the UI if it's visible
        this.updateClaimInUI(data);

        // Show notification based on type
        let notificationType = 'info';
        if (data.Type === 'status_change') {
            if (data.NewStatus === 'Approved' || data.NewStatus === 'Completed') {
                notificationType = 'success';
            } else if (data.NewStatus === 'Rejected') {
                notificationType = 'error';
            } else if (data.NewStatus === 'OnHold') {
                notificationType = 'warning';
            }
        }

        this.handleNotification(data.Message, notificationType);

        // Increment notification bell counter
        if (window.notificationManager) {
            window.notificationManager.increment();
        }

        // Refresh dashboard statistics
        if (typeof refreshDashboardStats === 'function') {
            refreshDashboardStats();
        }
    }

    /**
     * Add new claim to dashboard table
     */
    addClaimToDashboardTable(data) {
        const dashboardTable = document.querySelector('#dashboard-claims-table tbody');
        if (!dashboardTable) {
            console.log('Dashboard table not found, cannot add new claim');
            return;
        }

        console.log('Adding new claim to dashboard table:', data);

        // NOTE: ASP.NET Core sends property names in camelCase (lowercase first letter)
        // So we need to use: claimId, vin, vehicleModel, serviceCenterName, statusCode, etc.

        // Create new row matching dashboard structure:
        // ClaimID, Model, VIN, Status, Service Center, Created, Actions
        const row = document.createElement('tr');
        row.setAttribute('data-claim-id', data.claimId || data.ClaimId);
        row.className = 'new-row-animation';

        row.innerHTML = `
            <td>${data.claimId || data.ClaimId}</td>
            <td>${data.vehicleModel || data.VehicleModel || 'N/A'}</td>
            <td>${data.vin || data.Vin}</td>
            <td><span class="badge bg-${this.getStatusColor(data.statusCode || data.StatusCode || 'Pending')}">${data.statusCode || data.StatusCode || 'Pending'}</span></td>
            <td>${data.serviceCenterName || data.ServiceCenterName || 'Unknown'}</td>
            <td>Just now</td>
            <td class="text-nowrap">
                <a class="btn btn-sm btn-outline-primary" href="/Claims/Detail?id=${data.claimId || data.ClaimId}">Detail</a>
            </td>
        `;

        // Add to top of table
        dashboardTable.prepend(row);

        // Remove animation class after animation completes
        setTimeout(() => row.classList.remove('new-row-animation'), 500);
    }

    /**
     * Update a claim in the UI
     */
    updateClaimInUI(data) {
        // Find claim row if it exists
        const claimRow = document.querySelector(`[data-claim-id="${data.ClaimId}"]`);
        if (!claimRow) {
            console.log(`Claim row not found for ClaimId: ${data.ClaimId}`);
            return;
        }

        console.log('Updating claim in dashboard:', data);

        // Update status badge - in dashboard, status is in 4th column (index 3)
        if (data.NewStatus) {
            const statusCell = claimRow.cells[3]; // Status column
            if (statusCell) {
                statusCell.innerHTML = `<span class="badge bg-${this.getStatusColor(data.NewStatus)} badge-pulse">${data.NewStatus}</span>`;

                // Remove pulse animation after 1 second
                setTimeout(() => {
                    const badge = statusCell.querySelector('.badge');
                    if (badge) badge.classList.remove('badge-pulse');
                }, 1000);
            }
        }

        // Highlight the row briefly
        claimRow.classList.add('table-row-highlight');
        setTimeout(() => claimRow.classList.remove('table-row-highlight'), 2000);
    }

    /**
     * Add new claim to recent claims list
     */
    addClaimToRecentList(data) {
        const recentClaimsList = document.getElementById('recent-claims-list');
        if (!recentClaimsList) return;

        // Create new claim item
        const claimItem = document.createElement('div');
        claimItem.className = 'list-group-item list-group-item-action new-claim-animation';
        claimItem.innerHTML = `
            <div class="d-flex w-100 justify-content-between">
                <h6 class="mb-1">Claim #${data.ClaimId}</h6>
                <small class="text-muted">Just now</small>
            </div>
            <p class="mb-1">VIN: ${data.Vin}</p>
            <small class="text-muted">${data.ServiceCenterName}</small>
        `;

        // Add to top of list
        recentClaimsList.prepend(claimItem);

        // Remove animation class after it completes
        setTimeout(() => claimItem.classList.remove('new-claim-animation'), 500);

        // Limit list to 10 items
        const items = recentClaimsList.querySelectorAll('.list-group-item');
        if (items.length > 10) {
            items[items.length - 1].remove();
        }
    }

    /**
     * Get Bootstrap color class for status
     */
    getStatusColor(status) {
        const colorMap = {
            'Pending': 'warning',
            'Approved': 'success',
            'Rejected': 'danger',
            'OnHold': 'secondary',
            'InProgress': 'info',
            'Completed': 'success',
            'Closed': 'dark'
        };
        return colorMap[status] || 'secondary';
    }

    /**
     * Update connection status indicator
     */
    updateConnectionStatus(state) {
        const indicator = document.getElementById('connection-status-indicator');
        if (!indicator) return;

        const statusIcon = indicator.querySelector('i');
        const statusText = indicator.querySelector('.status-text');

        indicator.className = 'connection-status';

        switch (state) {
            case 'connected':
                indicator.classList.add('connected');
                if (statusIcon) statusIcon.className = 'bi bi-circle-fill';
                if (statusText) statusText.textContent = 'Connected';
                break;
            case 'connecting':
            case 'reconnecting':
                indicator.classList.add('connecting');
                if (statusIcon) statusIcon.className = 'bi bi-arrow-repeat';
                if (statusText) statusText.textContent = 'Connecting...';
                break;
            case 'disconnected':
            case 'error':
                indicator.classList.add('disconnected');
                if (statusIcon) statusIcon.className = 'bi bi-x-circle-fill';
                if (statusText) statusText.textContent = 'Disconnected';
                break;
        }
    }

    /**
     * Stop the real-time connection
     */
    async stop() {
        if (this.notificationHub) {
            await this.notificationHub.stop();
            this.isInitialized = false;
            console.log('Dashboard real-time stopped');
        }
    }
}

// Initialize when DOM is ready
let dashboardRealTime;

document.addEventListener('DOMContentLoaded', function() {
    dashboardRealTime = new DashboardRealTime();
    dashboardRealTime.initialize();
});

// Clean up on page unload
window.addEventListener('beforeunload', function() {
    if (dashboardRealTime) {
        dashboardRealTime.stop();
    }
});

--------------------------------------------------------------------------------
File: EVWarrantyManagement/wwwroot/js/claims-realtime.js
--------------------------------------------------------------------------------

/**
 * Claims Page Real-Time Updates via SignalR
 * Handles live claim updates on claims listing and details pages
 */

class ClaimsRealTime {
    constructor() {
        this.notificationHub = null;
        this.isInitialized = false;
        this.currentClaimId = null;
    }

    /**
     * Initialize the claims real-time connection
     * @param {number} claimId - Optional claim ID if on details page
     */
    async initialize(claimId = null) {
        if (this.isInitialized) {
            console.warn('Claims real-time already initialized');
            return;
        }

        this.currentClaimId = claimId;

        try {
            // Create SignalR connection to notification hub
            this.notificationHub = new SignalRConnection('/hubs/notification');

            // Register event handlers
            this.registerEventHandlers();

            // Start the connection
            await this.notificationHub.start();

            // If on a claim details page, join the claim group
            if (this.currentClaimId) {
                await this.joinClaimGroup(this.currentClaimId);
            }

            this.isInitialized = true;
            console.log('Claims real-time initialized');

        } catch (error) {
            console.error('Failed to initialize claims real-time:', error);
        }
    }

    /**
     * Register SignalR event handlers
     */
    registerEventHandlers() {
        // Handle general notifications
        this.notificationHub.on('ReceiveNotification', (message, type) => {
            this.handleNotification(message, type);
        });

        // Handle claim updates
        this.notificationHub.on('ReceiveClaimUpdate', (data) => {
            this.handleClaimUpdate(data);
        });

        // Handle new claims
        this.notificationHub.on('ReceiveNewClaim', (data) => {
            this.handleNewClaim(data);
        });
    }

    /**
     * Join a claim-specific group for targeted updates
     */
    async joinClaimGroup(claimId) {
        if (!this.notificationHub) return;

        try {
            await this.notificationHub.invoke('JoinClaimGroup', claimId);
            console.log(`Joined claim group: ${claimId}`);
        } catch (error) {
            console.error(`Failed to join claim group ${claimId}:`, error);
        }
    }

    /**
     * Leave a claim-specific group
     */
    async leaveClaimGroup(claimId) {
        if (!this.notificationHub) return;

        try {
            await this.notificationHub.invoke('LeaveClaimGroup', claimId);
            console.log(`Left claim group: ${claimId}`);
        } catch (error) {
            console.error(`Failed to leave claim group ${claimId}:`, error);
        }
    }

    /**
     * Handle general notification
     */
    handleNotification(message, type = 'info') {
        if (window.notificationToast) {
            window.notificationToast.show(message, type);
        }
        console.log(`[${type.toUpperCase()}] ${message}`);
    }

    /**
     * Handle claim update
     */
    handleClaimUpdate(data) {
        console.log('Claim update received:', data);

        // If we're on the claim details page for this claim, update the UI
        if (this.currentClaimId && this.currentClaimId === data.ClaimId) {
            this.updateClaimDetailsPage(data);
        }

        // If we're on the claims list, update the table row
        this.updateClaimInTable(data);

        // Show notification
        let notificationType = 'info';
        if (data.Type === 'status_change') {
            if (data.NewStatus === 'Approved' || data.NewStatus === 'Completed') {
                notificationType = 'success';
            } else if (data.NewStatus === 'Rejected') {
                notificationType = 'error';
            } else if (data.NewStatus === 'OnHold') {
                notificationType = 'warning';
            }
        } else if (data.Type === 'part_added') {
            notificationType = 'success';
        }

        this.handleNotification(data.Message, notificationType);

        // Increment notification bell counter
        if (window.notificationManager) {
            window.notificationManager.increment();
        }
    }

    /**
     * Handle new claim
     */
    handleNewClaim(data) {
        console.log('New claim received:', data);

        // Add to the claims table if it exists
        this.addClaimToTable(data);

        // Show notification
        this.handleNotification(data.Message, 'info');

        // Increment notification bell counter
        if (window.notificationManager) {
            window.notificationManager.increment();
        }
    }

    /**
     * Update claim details page UI
     */
    updateClaimDetailsPage(data) {
        // Update status badge
        if (data.NewStatus) {
            const statusBadge = document.querySelector('.claim-status-badge');
            if (statusBadge) {
                statusBadge.textContent = data.NewStatus;
                statusBadge.className = `badge claim-status-badge bg-${this.getStatusColor(data.NewStatus)} badge-pulse`;
                setTimeout(() => statusBadge.classList.remove('badge-pulse'), 1000);
            }

            // Update status field
            const statusField = document.getElementById('claim-status');
            if (statusField) {
                statusField.textContent = data.NewStatus;
            }
        }

        // Update total cost if changed
        if (data.TotalCost !== undefined) {
            const costElement = document.getElementById('claim-total-cost');
            if (costElement) {
                costElement.textContent = `$${data.TotalCost.toFixed(2)}`;
                costElement.classList.add('text-highlight');
                setTimeout(() => costElement.classList.remove('text-highlight'), 1500);
            }
        }

        // If a part was added, reload the parts table
        if (data.Type === 'part_added') {
            const partsTable = document.getElementById('used-parts-table');
            if (partsTable && typeof reloadUsedParts === 'function') {
                reloadUsedParts();
            }
        }

        // Add to activity log
        if (data.Message) {
            this.addToActivityLog(data);
        }
    }

    /**
     * Update claim in table (on claims list page)
     */
    updateClaimInTable(data) {
        const claimRow = document.querySelector(`tr[data-claim-id="${data.ClaimId}"]`);
        if (!claimRow) {
            console.log(`Claim row not found for ClaimId: ${data.ClaimId}`);
            return;
        }

        console.log('Updating claim in table:', data);

        // Update status - the status is in the 6th column (index 5)
        if (data.NewStatus) {
            const statusCell = claimRow.cells[5]; // Status column
            if (statusCell) {
                statusCell.innerHTML = `<span class="badge bg-${this.getStatusColor(data.NewStatus)} badge-pulse">${data.NewStatus}</span>`;
                setTimeout(() => {
                    const badge = statusCell.querySelector('.badge');
                    if (badge) badge.classList.remove('badge-pulse');
                }, 1000);
            }
        }

        // Highlight row to show it was updated
        claimRow.classList.add('table-row-highlight');
        setTimeout(() => claimRow.classList.remove('table-row-highlight'), 2000);
    }

    /**
     * Add new claim to table
     */
    addClaimToTable(data) {
        const claimsTable = document.querySelector('#claims-table tbody');
        if (!claimsTable) {
            console.log('Claims table not found, cannot add new claim to table');
            return;
        }

        console.log('Adding new claim to table:', data);

        // NOTE: ASP.NET Core sends property names in camelCase (lowercase first letter)
        // Support both PascalCase and camelCase for compatibility

        // Create new row matching the actual table structure:
        // ClaimID, Model, VIN, Description, Date, Status, Actions
        const row = document.createElement('tr');
        row.setAttribute('data-claim-id', data.claimId || data.ClaimId);
        row.className = 'new-row-animation';

        // Truncate description if too long
        const desc = data.description || data.Description || '';
        const description = desc.length > 50 ? desc.substring(0, 50) + '...' : (desc || 'N/A');

        row.innerHTML = `
            <td>${data.claimId || data.ClaimId}</td>
            <td>${data.vehicleModel || data.VehicleModel || 'N/A'}</td>
            <td>${data.vin || data.Vin}</td>
            <td class="text-truncate" style="max-width: 360px;">${description}</td>
            <td>${data.dateDiscovered || data.DateDiscovered || new Date().toLocaleDateString()}</td>
            <td><span class="badge bg-secondary">${data.statusCode || data.StatusCode || 'Pending'}</span></td>
            <td class="text-nowrap">
                <a class="btn btn-sm btn-secondary" href="/Claims/Details?id=${data.claimId || data.ClaimId}">Details</a>
            </td>
        `;

        // Add to top of table
        claimsTable.prepend(row);

        // Remove animation class after animation completes
        setTimeout(() => row.classList.remove('new-row-animation'), 500);
    }

    /**
     * Add entry to activity log
     */
    addToActivityLog(data) {
        const activityLog = document.getElementById('activity-log');
        if (!activityLog) return;

        const logEntry = document.createElement('div');
        logEntry.className = 'alert alert-info alert-dismissible fade show new-activity-animation';
        logEntry.innerHTML = `
            <i class="bi bi-info-circle me-2"></i>
            <strong>${data.Type || 'Update'}:</strong> ${data.Message}
            <small class="text-muted d-block mt-1">Just now</small>
            <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
        `;

        activityLog.prepend(logEntry);

        // Remove animation class
        setTimeout(() => logEntry.classList.remove('new-activity-animation'), 500);

        // Auto-dismiss after 10 seconds
        setTimeout(() => {
            if (logEntry.parentNode) {
                const bsAlert = new bootstrap.Alert(logEntry);
                bsAlert.close();
            }
        }, 10000);
    }

    /**
     * Get Bootstrap color class for status
     */
    getStatusColor(status) {
        const colorMap = {
            'Pending': 'warning',
            'Approved': 'success',
            'Rejected': 'danger',
            'OnHold': 'secondary',
            'InProgress': 'info',
            'Completed': 'success',
            'Closed': 'dark'
        };
        return colorMap[status] || 'secondary';
    }

    /**
     * Stop the real-time connection
     */
    async stop() {
        // Leave claim group if we're on a details page
        if (this.currentClaimId && this.notificationHub) {
            await this.leaveClaimGroup(this.currentClaimId);
        }

        if (this.notificationHub) {
            await this.notificationHub.stop();
            this.isInitialized = false;
            console.log('Claims real-time stopped');
        }
    }
}

// Export for global use
window.ClaimsRealTime = ClaimsRealTime;

// Auto-initialize if on claims page
document.addEventListener('DOMContentLoaded', function() {
    // Check if we're on a claims page
    const isClaimsPage = window.location.pathname.includes('/Claims');

    if (isClaimsPage) {
        // Check if we're on a claim details page
        const urlParams = new URLSearchParams(window.location.search);
        const claimId = urlParams.get('id');

        // Initialize claims real-time
        window.claimsRealTime = new ClaimsRealTime();
        window.claimsRealTime.initialize(claimId ? parseInt(claimId) : null);

        // Clean up on page unload
        window.addEventListener('beforeunload', function() {
            if (window.claimsRealTime) {
                window.claimsRealTime.stop();
            }
        });
    }
});

--------------------------------------------------------------------------------
File: EVWarrantyManagement/wwwroot/js/chat.js
--------------------------------------------------------------------------------

/**
 * Claim Chat Interface with SignalR
 * Handles real-time messaging for warranty claims
 */

class ClaimChat {
    constructor(claimId) {
        this.claimId = claimId;
        this.chatHub = null;
        this.isInitialized = false;
        this.typingTimer = null;
        this.typingDelay = 1000; // Stop typing indicator after 1 second
        this.currentUser = null;
    }

    /**
     * Initialize the chat connection
     */
    async initialize() {
        if (this.isInitialized) {
            console.warn('Chat already initialized');
            return;
        }

        try {
            // Create SignalR connection to chat hub
            this.chatHub = new SignalRConnection('/hubs/chat');

            // Register event handlers
            this.registerEventHandlers();

            // Start the connection
            await this.chatHub.start();

            // Join the claim chat room
            await this.joinChat();

            this.isInitialized = true;
            console.log(`Chat initialized for claim ${this.claimId}`);

            // Set up UI event handlers
            this.setupUIHandlers();

            // Load existing messages
            await this.loadMessages();

        } catch (error) {
            console.error('Failed to initialize chat:', error);
        }
    }

    /**
     * Register SignalR event handlers
     */
    registerEventHandlers() {
        // Handle incoming messages
        this.chatHub.on('ReceiveMessage', (data) => {
            this.handleIncomingMessage(data);
        });

        // Handle user joined
        this.chatHub.on('UserJoined', (username, timestamp) => {
            this.showSystemMessage(`${username} joined the chat`);
        });

        // Handle user left
        this.chatHub.on('UserLeft', (username, timestamp) => {
            this.showSystemMessage(`${username} left the chat`);
        });

        // Handle typing indicator
        this.chatHub.on('UserIsTyping', (username) => {
            this.showTypingIndicator(username);
        });

        this.chatHub.on('UserStoppedTyping', (username) => {
            this.hideTypingIndicator(username);
        });

        // Handle messages read
        this.chatHub.on('MessagesRead', (userId, timestamp) => {
            this.handleMessagesRead(userId);
        });

        // Handle message deleted
        this.chatHub.on('MessageDeleted', (messageId) => {
            this.removeMessage(messageId);
        });
    }

    /**
     * Join the claim chat room
     */
    async joinChat() {
        try {
            await this.chatHub.invoke('JoinClaimChat', this.claimId);
            console.log(`Joined chat for claim ${this.claimId}`);
        } catch (error) {
            console.error('Failed to join chat:', error);
        }
    }

    /**
     * Leave the claim chat room
     */
    async leaveChat() {
        try {
            await this.chatHub.invoke('LeaveClaimChat', this.claimId);
            console.log(`Left chat for claim ${this.claimId}`);
        } catch (error) {
            console.error('Failed to leave chat:', error);
        }
    }

    /**
     * Setup UI event handlers
     */
    setupUIHandlers() {
        const messageInput = document.getElementById('chat-message-input');
        const sendButton = document.getElementById('chat-send-button');

        if (messageInput) {
            // Send message on Enter key
            messageInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    this.sendMessage();
                }
            });

            // Typing indicator
            messageInput.addEventListener('input', () => {
                this.handleTyping();
            });
        }

        if (sendButton) {
            sendButton.addEventListener('click', () => {
                this.sendMessage();
            });
        }
    }

    /**
     * Load existing messages from server
     */
    async loadMessages() {
        try {
            const response = await fetch(`/api/messages/claim/${this.claimId}`);
            if (response.ok) {
                const messages = await response.json();
                this.renderMessages(messages);
            }
        } catch (error) {
            console.error('Failed to load messages:', error);
        }
    }

    /**
     * Send a message
     */
    async sendMessage() {
        const messageInput = document.getElementById('chat-message-input');
        if (!messageInput) return;

        const message = messageInput.value.trim();
        if (!message) return;

        try {
            // Send via SignalR (hub will broadcast to all users)
            await this.chatHub.invoke('SendMessage', this.claimId, message);

            // Clear input
            messageInput.value = '';

            // Stop typing indicator
            await this.chatHub.invoke('UserStoppedTyping', this.claimId);

        } catch (error) {
            console.error('Failed to send message:', error);
            if (window.notificationToast) {
                window.notificationToast.show('Failed to send message', 'error');
            }
        }
    }

    /**
     * Handle typing indicator
     */
    handleTyping() {
        // Clear existing timer
        if (this.typingTimer) {
            clearTimeout(this.typingTimer);
        }

        // Notify others that user is typing
        this.chatHub.invoke('UserTyping', this.claimId);

        // Set timer to stop typing indicator
        this.typingTimer = setTimeout(() => {
            this.chatHub.invoke('UserStoppedTyping', this.claimId);
        }, this.typingDelay);
    }

    /**
     * Handle incoming message
     */
    handleIncomingMessage(data) {
        this.appendMessage(data);

        // Mark as read if the chat window is visible
        const chatContainer = document.getElementById('chat-messages');
        if (chatContainer && this.isVisible(chatContainer)) {
            this.markMessagesAsRead();
        }

        // Play notification sound if message is from another user
        if (data.UserId !== this.currentUser?.userId) {
            this.playMessageSound();
        }
    }

    /**
     * Append a message to the chat UI
     */
    appendMessage(data) {
        const chatMessages = document.getElementById('chat-messages');
        if (!chatMessages) return;

        const isOwnMessage = data.UserId === this.currentUser?.userId;

        const messageDiv = document.createElement('div');
        messageDiv.className = `chat-message ${isOwnMessage ? 'own-message' : 'other-message'} message-fade-in`;
        messageDiv.setAttribute('data-message-id', data.MessageId);

        const timestamp = new Date(data.Timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

        messageDiv.innerHTML = `
            <div class="message-header">
                <strong>${data.Username}</strong>
                <small class="text-muted">${timestamp}</small>
            </div>
            <div class="message-content">${this.escapeHtml(data.Message)}</div>
        `;

        chatMessages.appendChild(messageDiv);

        // Scroll to bottom
        this.scrollToBottom();

        // Remove animation class
        setTimeout(() => messageDiv.classList.remove('message-fade-in'), 300);
    }

    /**
     * Render multiple messages
     */
    renderMessages(messages) {
        const chatMessages = document.getElementById('chat-messages');
        if (!chatMessages) return;

        chatMessages.innerHTML = '';

        messages.forEach(msg => {
            this.appendMessage(msg);
        });
    }

    /**
     * Show system message
     */
    showSystemMessage(message) {
        const chatMessages = document.getElementById('chat-messages');
        if (!chatMessages) return;

        const messageDiv = document.createElement('div');
        messageDiv.className = 'chat-system-message message-fade-in';
        messageDiv.innerHTML = `<small class="text-muted"><i class="bi bi-info-circle"></i> ${message}</small>`;

        chatMessages.appendChild(messageDiv);
        this.scrollToBottom();
    }

    /**
     * Show typing indicator
     */
    showTypingIndicator(username) {
        const typingIndicator = document.getElementById('typing-indicator');
        if (!typingIndicator) return;

        typingIndicator.textContent = `${username} is typing...`;
        typingIndicator.classList.remove('d-none');
    }

    /**
     * Hide typing indicator
     */
    hideTypingIndicator(username) {
        const typingIndicator = document.getElementById('typing-indicator');
        if (!typingIndicator) return;

        typingIndicator.classList.add('d-none');
    }

    /**
     * Mark messages as read
     */
    async markMessagesAsRead() {
        try {
            await this.chatHub.invoke('MarkMessagesAsRead', this.claimId);
        } catch (error) {
            console.error('Failed to mark messages as read:', error);
        }
    }

    /**
     * Handle messages read event
     */
    handleMessagesRead(userId) {
        // Update UI to show read receipts if needed
        console.log(`User ${userId} read messages`);
    }

    /**
     * Remove a message from UI
     */
    removeMessage(messageId) {
        const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
        if (messageElement) {
            messageElement.classList.add('message-fade-out');
            setTimeout(() => messageElement.remove(), 300);
        }
    }

    /**
     * Scroll chat to bottom
     */
    scrollToBottom() {
        const chatMessages = document.getElementById('chat-messages');
        if (chatMessages) {
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
    }

    /**
     * Check if element is visible
     */
    isVisible(element) {
        return element.offsetParent !== null;
    }

    /**
     * Play message notification sound
     */
    playMessageSound() {
        try {
            const context = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = context.createOscillator();
            const gainNode = context.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(context.destination);

            oscillator.frequency.value = 600;
            oscillator.type = 'sine';

            gainNode.gain.setValueAtTime(0.05, context.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, context.currentTime + 0.1);

            oscillator.start(context.currentTime);
            oscillator.stop(context.currentTime + 0.1);
        } catch (e) {
            // Silently fail if audio is not supported
        }
    }

    /**
     * Escape HTML to prevent XSS
     */
    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    /**
     * Stop the chat connection
     */
    async stop() {
        await this.leaveChat();

        if (this.chatHub) {
            await this.chatHub.stop();
            this.isInitialized = false;
            console.log('Chat stopped');
        }
    }
}

// Export for global use
window.ClaimChat = ClaimChat;

================================================================================
                        III. STYLING
================================================================================

--------------------------------------------------------------------------------
File: EVWarrantyManagement/wwwroot/css/signalr-styles.css
--------------------------------------------------------------------------------

/**
 * SignalR Real-Time Styles
 * Animations, transitions, and styling for real-time features
 */

/* ===== Toast Notifications ===== */
.toast-container {
    z-index: 9999 !important;
}

/* ===== Animations ===== */
@keyframes fadeIn {
    from {
        opacity: 0;
        transform: translateY(-10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

@keyframes slideInRight {
    from {
        opacity: 0;
        transform: translateX(100px);
    }
    to {
        opacity: 1;
        transform: translateX(0);
    }
}

@keyframes pulse {
    0% {
        box-shadow: 0 0 0 0 rgba(13, 202, 240, 0.7);
    }
    50% {
        box-shadow: 0 0 0 10px rgba(13, 202, 240, 0);
    }
    100% {
        box-shadow: 0 0 0 0 rgba(13, 202, 240, 0);
    }
}

@keyframes highlight {
    0% {
        background-color: transparent;
    }
    50% {
        background-color: rgba(255, 193, 7, 0.3);
    }
    100% {
        background-color: transparent;
    }
}

/* ===== Badge Animations ===== */
.badge-pulse {
    animation: pulse 1s ease-in-out;
}

/* ===== Table Row Animations ===== */
.table-row-highlight {
    animation: highlight 2s ease-in-out;
}

.new-row-animation {
    animation: slideInRight 0.5s ease-out;
}

/* ===== Text Highlight ===== */
.text-highlight {
    animation: highlight 1.5s ease-in-out;
}

/* ===== New Activity Animation ===== */
.new-activity-animation {
    animation: fadeIn 0.5s ease-out;
}

.new-claim-animation {
    animation: slideInRight 0.5s ease-out;
}

/* ===== Connection Status Indicator ===== */
.connection-status {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.25rem 0.75rem;
    border-radius: 1rem;
    font-size: 0.85rem;
    transition: all 0.3s ease;
}

.connection-status.connected {
    background-color: #d1e7dd;
    color: #0f5132;
}

.connection-status.connected i {
    color: #198754;
}

.connection-status.connecting {
    background-color: #fff3cd;
    color: #664d03;
}

.connection-status.connecting i {
    color: #ffc107;
    animation: spin 1s linear infinite;
}

.connection-status.disconnected {
    background-color: #f8d7da;
    color: #842029;
}

.connection-status.disconnected i {
    color: #dc3545;
}

@keyframes spin {
    from {
        transform: rotate(0deg);
    }
    to {
        transform: rotate(360deg);
    }
}

/* ===== Chat Styles ===== */
.chat-container {
    display: flex;
    flex-direction: column;
    height: 500px;
    border: 1px solid #dee2e6;
    border-radius: 0.5rem;
    background-color: #f8f9fa;
}

.chat-header {
    padding: 1rem;
    background-color: #0d6efd;
    color: white;
    border-top-left-radius: 0.5rem;
    border-top-right-radius: 0.5rem;
    font-weight: 600;
}

#chat-messages {
    flex: 1;
    overflow-y: auto;
    padding: 1rem;
    background-color: white;
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
}

.chat-message {
    display: flex;
    flex-direction: column;
    max-width: 70%;
    padding: 0.75rem;
    border-radius: 0.5rem;
    word-wrap: break-word;
}

.chat-message.own-message {
    align-self: flex-end;
    background-color: #0d6efd;
    color: white;
}

.chat-message.other-message {
    align-self: flex-start;
    background-color: #e9ecef;
    color: #212529;
}

.message-header {
    display: flex;
    justify-content: space-between;
    margin-bottom: 0.25rem;
    font-size: 0.85rem;
}

.message-content {
    font-size: 0.95rem;
    line-height: 1.4;
}

.chat-system-message {
    align-self: center;
    padding: 0.5rem;
    text-align: center;
}

.message-fade-in {
    animation: fadeIn 0.3s ease-out;
}

.message-fade-out {
    animation: fadeOut 0.3s ease-out;
}

@keyframes fadeOut {
    from {
        opacity: 1;
    }
    to {
        opacity: 0;
    }
}

.chat-input-area {
    padding: 1rem;
    background-color: #f8f9fa;
    border-top: 1px solid #dee2e6;
    border-bottom-left-radius: 0.5rem;
    border-bottom-right-radius: 0.5rem;
}

.chat-input-group {
    display: flex;
    gap: 0.5rem;
}

#chat-message-input {
    flex: 1;
    resize: none;
    min-height: 40px;
    max-height: 100px;
}

#typing-indicator {
    padding: 0.5rem 1rem;
    font-size: 0.85rem;
    font-style: italic;
    color: #6c757d;
}

#typing-indicator.d-none {
    display: none;
}

/* ===== Chat Button ===== */
.chat-toggle-btn {
    position: fixed;
    bottom: 2rem;
    right: 2rem;
    width: 60px;
    height: 60px;
    border-radius: 50%;
    background-color: #0d6efd;
    color: white;
    border: none;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.5rem;
    cursor: pointer;
    transition: all 0.3s ease;
    z-index: 1000;
}

.chat-toggle-btn:hover {
    background-color: #0b5ed7;
    transform: scale(1.1);
}

.chat-toggle-btn .unread-badge {
    position: absolute;
    top: -5px;
    right: -5px;
    background-color: #dc3545;
    color: white;
    border-radius: 50%;
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.75rem;
    font-weight: bold;
}

/* ===== Modal Chat Window ===== */
.chat-modal .modal-dialog {
    max-width: 600px;
}

.chat-modal .modal-body {
    padding: 0;
}

/* ===== Notification Styles ===== */
.notification-item {
    padding: 0.75rem;
    border-bottom: 1px solid #dee2e6;
    transition: background-color 0.2s ease;
}

.notification-item:hover {
    background-color: #f8f9fa;
}

.notification-item.unread {
    background-color: #e7f3ff;
    font-weight: 600;
}

.notification-icon {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.2rem;
}

.notification-icon.info {
    background-color: #cfe2ff;
    color: #084298;
}

.notification-icon.success {
    background-color: #d1e7dd;
    color: #0f5132;
}

.notification-icon.warning {
    background-color: #fff3cd;
    color: #664d03;
}

.notification-icon.error {
    background-color: #f8d7da;
    color: #842029;
}

/* ===== Real-Time Counter Badge ===== */
.realtime-counter {
    position: relative;
    display: inline-block;
}

.realtime-counter .badge {
    transition: all 0.3s ease;
}

.realtime-counter .badge.updating {
    animation: pulse 0.6s ease-in-out;
}

/* ===== Status Badge Colors ===== */
.status-badge.bg-pending {
    background-color: #ffc107 !important;
}

.status-badge.bg-approved {
    background-color: #198754 !important;
}

.status-badge.bg-rejected {
    background-color: #dc3545 !important;
}

.status-badge.bg-onhold {
    background-color: #6c757d !important;
}

.status-badge.bg-inprogress {
    background-color: #0dcaf0 !important;
}

.status-badge.bg-completed {
    background-color: #198754 !important;
}

.status-badge.bg-closed {
    background-color: #212529 !important;
}

/* ===== Responsive Styles ===== */
@media (max-width: 768px) {
    .chat-container {
        height: 400px;
    }

    .chat-message {
        max-width: 85%;
    }

    .chat-toggle-btn {
        bottom: 1rem;
        right: 1rem;
        width: 50px;
        height: 50px;
        font-size: 1.25rem;
    }

    .toast-container {
        max-width: 100% !important;
        left: 0.5rem !important;
        right: 0.5rem !important;
    }
}

/* ===== Scrollbar Styling for Chat ===== */
#chat-messages::-webkit-scrollbar {
    width: 8px;
}

#chat-messages::-webkit-scrollbar-track {
    background: #f1f1f1;
}

#chat-messages::-webkit-scrollbar-thumb {
    background: #888;
    border-radius: 4px;
}

#chat-messages::-webkit-scrollbar-thumb:hover {
    background: #555;
}

/* ===== Notification Bell ===== */
.notification-bell-container {
    position: relative;
    display: inline-block;
    margin-right: 15px;
}

.notification-bell {
    font-size: 1.5rem;
    color: #6c757d;
    cursor: pointer;
    transition: color 0.3s ease;
    text-decoration: none;
}

.notification-bell:hover {
    color: #495057;
}

.notification-badge {
    position: absolute;
    top: -8px;
    right: -10px;
    background-color: #dc3545;
    color: white;
    border-radius: 50%;
    padding: 2px 6px;
    font-size: 0.75rem;
    font-weight: bold;
    min-width: 18px;
    height: 18px;
    display: none;
    text-align: center;
    line-height: 14px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

/* Shake animation for notification bell */
@keyframes bellShake {
    0%, 100% { transform: rotate(0deg); }
    10%, 30%, 50%, 70%, 90% { transform: rotate(-10deg); }
    20%, 40%, 60%, 80% { transform: rotate(10deg); }
}

.notification-bell-shake {
    animation: bellShake 0.5s ease-in-out;
}

/* Pulse animation for badge */
@keyframes badgePulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.2); }
    100% { transform: scale(1); }
}

.notification-badge-pulse {
    animation: badgePulse 0.5s ease-in-out;
}

================================================================================
                        IV. DATABASE
================================================================================

--------------------------------------------------------------------------------
File: AddClaimMessagesTable.sql
--------------------------------------------------------------------------------

-- Script to add ClaimMessages table for SignalR chat functionality
-- Execute this in SQL Server Management Studio or Azure Data Studio

USE [EVWarrantyManagement]
GO

-- Check if table already exists, drop if it does (for re-running script)
IF OBJECT_ID('[ev].[ClaimMessages]', 'U') IS NOT NULL
    DROP TABLE [ev].[ClaimMessages]
GO

-- Create ClaimMessages table
CREATE TABLE [ev].[ClaimMessages](
    [MessageId] [int] IDENTITY(1,1) NOT NULL,
    [ClaimId] [int] NOT NULL,
    [UserId] [int] NOT NULL,
    [Message] [nvarchar](2000) NOT NULL,
    [Timestamp] [datetime2](7) NOT NULL,
    [IsRead] [bit] NOT NULL,
    [ReadAt] [datetime2](7) NULL,
    CONSTRAINT [PK__ClaimMes__C87C0C9C1234ABCD] PRIMARY KEY CLUSTERED ([MessageId] ASC)
        WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO

-- Add default constraints
ALTER TABLE [ev].[ClaimMessages] ADD CONSTRAINT [DF_ClaimMessages_Timestamp] DEFAULT (SYSUTCDATETIME()) FOR [Timestamp]
GO

ALTER TABLE [ev].[ClaimMessages] ADD CONSTRAINT [DF_ClaimMessages_IsRead] DEFAULT ((0)) FOR [IsRead]
GO

-- Add foreign key to WarrantyClaim table (singular, not plural)
ALTER TABLE [ev].[ClaimMessages] WITH CHECK ADD CONSTRAINT [FK_ClaimMessage_WarrantyClaim]
    FOREIGN KEY([ClaimId])
    REFERENCES [ev].[WarrantyClaim] ([ClaimId])
    ON DELETE CASCADE
GO

ALTER TABLE [ev].[ClaimMessages] CHECK CONSTRAINT [FK_ClaimMessage_WarrantyClaim]
GO

-- Add foreign key to Users table
ALTER TABLE [ev].[ClaimMessages] WITH CHECK ADD CONSTRAINT [FK_ClaimMessage_User]
    FOREIGN KEY([UserId])
    REFERENCES [ev].[Users] ([UserId])
GO

ALTER TABLE [ev].[ClaimMessages] CHECK CONSTRAINT [FK_ClaimMessage_User]
GO

-- Create indexes for better query performance
CREATE NONCLUSTERED INDEX [IX_ClaimMessage_ClaimId] ON [ev].[ClaimMessages]
(
    [ClaimId] ASC
) WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO

CREATE NONCLUSTERED INDEX [IX_ClaimMessage_Timestamp] ON [ev].[ClaimMessages]
(
    [Timestamp] ASC
) WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO

PRINT 'ClaimMessages table created successfully!'
GO

================================================================================
                        END OF SIGNALR CODEBASE
================================================================================

Generated: 2025
Project: EV Warranty Management System
Purpose: Complete SignalR real-time notification and chat implementation

For setup instructions, refer to SIGNALR_SETUP.md in the project root.
